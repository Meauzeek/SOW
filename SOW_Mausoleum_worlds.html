<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>“陵墓”子世界三维坐标图</title>
    <!-- 引入Tailwind CSS 用于页面美化 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Inter和Roboto Mono字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
            background-color: #f3f4f6; /* gray-100 */
        }
        #tooltip {
            position: absolute;
            display: none;
            width: 320px;
            padding: 1.25rem; /* 20px */
            background-color: rgba(249, 250, 251, 0.7); /* gray-50/70 */
            border: 1px solid transparent;
            border-radius: 16px;
            color: #1f2937; /* gray-800 */
            font-size: 14px;
            pointer-events: none;
            white-space: normal;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            z-index: 100;
            transition: opacity 0.2s ease-in-out;
            border-image: linear-gradient(to bottom right, #a5b4fc, #34d399) 1;
        }
        .coord-label {
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
        }
        .livability-text {
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
        }
    </style>
</head>
<body class="text-gray-800">

    <div id="header" class="absolute top-0 left-0 w-full p-4 md:p-6 text-center pointer-events-none z-10 transition-opacity duration-300">
        <header>
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">“陵墓” (The Mausoleum)</h1>
            <p class="text-lg md:text-xl text-gray-500 mt-1">子世界三维分布全息图</p>
        </header>
    </div>
    
    <!-- UI 控制面板 -->
    <div class="absolute top-4 left-4 bg-white/80 backdrop-blur-sm p-4 rounded-lg shadow-md z-20">
        <h3 class="font-bold mb-2 text-gray-700">显示选项</h3>
        <div class="space-y-2">
            <div class="flex items-center">
                <input type="checkbox" id="toggle-title" class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500" checked>
                <label for="toggle-title" class="ml-2 text-sm text-gray-600">显示标题</label>
            </div>
            <div class="flex items-center">
                <input type="checkbox" id="toggle-quadrants" class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500" checked>
                <label for="toggle-quadrants" class="ml-2 text-sm text-gray-600">显示象限平面</label>
            </div>
        </div>
    </div>
    
    <!-- 宜居度色阶条 -->
    <div id="legend" class="absolute bottom-4 right-4 p-3 bg-white/80 backdrop-blur-sm rounded-lg shadow-md z-20 flex flex-col items-center pointer-events-none">
        <div class="w-4 h-48 rounded" style="background: linear-gradient(to top, #ff0000, #c000c0, #0000ff, #008080, #00ff00, #adff2f);"></div>
        <div class="flex justify-between w-full mt-1 text-xs text-gray-500 flex-col h-48 absolute top-3 right-8">
             <span class="self-end">1.0　</span>
             <span class="self-end">0.0　</span>
        </div>
        <div class="mt-2 text-sm font-bold text-gray-700" title="宜居度 = (现实强度 * 个体自由度) * (1 - |无序度 - 0.3|)">宜居度</div>
    </div>


    <!-- three.js 渲染的容器 -->
    <div id="container"></div>
    
    <!-- 悬停信息提示框 -->
    <div id="tooltip"></div>

    <!-- 引入three.js核心库和OrbitControls控制器 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- 1. 初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6); // gray-100
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('container').appendChild(labelRenderer.domElement);

        // --- 2. 数据定义 ---
        const mausoleumData = [
            { name_cn: '地球', name_en: 'Earth', x: 0.9855, y: 0.8234, z: 0.3588, desc: '基准世界，充满可能性与缺陷' },
            { name_cn: '奥比奎亚', name_en: 'Orbiquia', x: 0.9780, y: 0.7231, z: 0.4132, desc: '与地球同级的“双胞胎”世界，科技更发达' },
            { name_cn: '光明境', name_en: 'Lucidia', x: 0.9134, y: 0.9876, z: 0.2543, desc: '后匮乏时代的乌托邦，专注于自我实现' },
            { name_cn: '样板间', name_en: 'The Showroom', x: 1.0000, y: 1.0000, z: 0.1000, desc: '“先驱”文明从未实现的、绝对完美的理想社会蓝图' },
            { name_cn: '织梦海', name_en: 'Oneiros', x: 0.1234, y: 0.9567, z: 0.8976, desc: '纯意识构成的梦境世界，想象力是物理法则' },
            { name_cn: '阿斯帕拉戈', name_en: 'Asparague', x: 0.7543, y: 0.6112, z: 0.5211, desc: '拥有多种智慧种族的剑与魔法式异世界' },
            { name_cn: '共治政体', name_en: 'Synarchy', x: 0.5512, y: 0.5000, z: 0.4867, desc: '两种智慧生命强制共生的平衡社会' },
            { name_cn: '拟象界', name_en: 'Simulacra', x: 0.2556, y: 0.4533, z: 0.3229, desc: '由活的文具和工具构成的奇异文明' },
            { name_cn: '爱伊忒拿', name_en: 'Aëterna', x: 0.8505, y: 0.2077, z: 0.0533, desc: '由超级AI管理的、追求绝对秩序的后人类社会' },
            { name_cn: '忘川', name_en: 'Lethe', x: 0.7123, y: 0.2245, z: 0.2845, desc: '记忆是可消耗资源的悲剧世界' },
            { name_cn: '熔炉', name_en: 'Crucible', x: 0.3109, y: 0.2109, z: 0.7234, desc: '非碳基生命的演化试验场' },
            { name_cn: '共生体', name_en: 'Koinonia', x: 0.4578, y: 0.3011, z: 0.6522, desc: '智慧体必须寄生于巨大宿主的脆弱世界' },
            { name_cn: '永恒之战', name_en: 'Perpetua', x: 0.6543, y: 0.1234, z: 0.9511, desc: '以冲突为唯一驱动力的战争沙盒' },
            { name_cn: '多米诺', name_en: 'Domino', x: 0.8034, y: 0.1345, z: 0.6876, desc: '现实逐层降级的嵌套陵墓' },
            { name_cn: '平台世界', name_en: 'The Terrace', x: 0.9522, y: 0.1188, z: 0.1534, desc: '抹杀所有可能性的、绝对平庸的世界' },
            { name_cn: '拼布世界', name_en: 'Patchwork', x: 0.1011, y: 0.0899, z: 0.9987, desc: '规则与现实混乱交错的衰变陵墓' },
            { name_cn: '范式', name_en: 'The Pattern', x: 0.9013, y: 0.0543, z: 0.0213, desc: '所有个体均为同一意识源的复制品' },
            { name_cn: '独我', name_en: 'Solus', x: 0.8567, y: 0.0611, z: 0.0288, desc: '只有一个真人与无数AI的世界' },
            { name_cn: '腹地', name_en: 'Hinterland', x: 0.9255, y: 0.0000, z: 0.0111, desc: '由无意识的“哲学僵尸”构成的文明档案馆' },
            { name_cn: '蜡像馆', name_en: 'The Wax Museum', x: 1.0000, y: 0.0000, z: 0.0001, desc: '时间被永久凝固的、栩栩如生的文明快照' },
            { name_cn: '提亚马特', name_en: 'Tiamat', x: 0.2105, y: 0.0000, z: 1.0000, desc: '整个星球是一个统一的、癌变的活体地狱' },
            { name_cn: '原点', name_en: 'The Origin', x: 0.0000, y: 0.0000, z: 0.0000, desc: '宇宙诞生前的混沌奇点，绝对的虚无' },
            { name_cn: '锚定岛', name_en: 'The Anchor Isle', x: 0.5000, y: 0.5000, z: 0.5000, desc: '维度中转站，校准和稳定不同陵墓的参数' }
        ];

        // --- 3. 宜居度计算与颜色映射 ---
        const idealDisorder = 0.3;
        const colors = [
            new THREE.Color(0xff0000), // 红
            new THREE.Color(0xc000c0), // 紫红
            new THREE.Color(0x0000ff), // 蓝
            new THREE.Color(0x008080), // 蓝绿
            new THREE.Color(0x00ff00), // 翠绿
            new THREE.Color(0xadff2f)  // 黄绿
        ];

        const getColor = (value) => {
            const colorIndex = Math.floor(value * (colors.length - 1));
            const t = value * (colors.length - 1) - colorIndex;
            if (colorIndex >= colors.length - 1) return colors[colors.length - 1];
            return new THREE.Color().lerpColors(colors[colorIndex], colors[colorIndex + 1], t);
        };

        mausoleumData.forEach(world => {
            let livability = (world.x * world.y) * (1 - Math.abs(world.z - idealDisorder));
            world.livability = Math.max(0, Math.min(livability, 1));
            world.color = getColor(world.livability);
        });

        // --- 4. 创建场景对象 ---
        const CUBE_SIZE = 10;
        const objects = [];
        const group = new THREE.Group();
        scene.add(group);

        // 坐标轴
        const axisColors = { x: '#4169E1', y: '#34C759', z: '#8A2BE2' }; // Royal Blue, Emerald, Violet
        const createAxis = (dir, color) => {
            const origin = new THREE.Vector3(0,0,0);
            const length = CUBE_SIZE;
            const arrowHelper = new THREE.ArrowHelper(dir, origin, length, color, 0.4, 0.2);
            arrowHelper.line.material.linewidth = 3;
            group.add(arrowHelper);
        };
        createAxis(new THREE.Vector3(1, 0, 0), axisColors.x);
        createAxis(new THREE.Vector3(0, 1, 0), axisColors.y);
        createAxis(new THREE.Vector3(0, 0, 1), axisColors.z);

        // 坐标轴标签
        const createLabel = (text, position, color) => {
            const div = document.createElement('div');
            div.className = 'font-bold text-lg';
            div.textContent = text;
            div.style.color = color;
            const label = new CSS2DObject(div);
            label.position.copy(position);
            group.add(label);
        };
        createLabel('X: 现实强度', new THREE.Vector3(CUBE_SIZE + 1.5, 0, 0), axisColors.x);
        createLabel('Y: 个体自由度', new THREE.Vector3(0, CUBE_SIZE + 1.5, 0), axisColors.y);
        createLabel('Z: 无序度', new THREE.Vector3(0, 0, CUBE_SIZE + 1.5), axisColors.z);

        // 象限分割平面
        const planeGroup = new THREE.Group();
        const planeGeom = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
        
        const planeXY = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({ color: axisColors.z, side: THREE.DoubleSide, transparent: true, opacity: 0.1 }));
        planeXY.position.set(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2);
        planeGroup.add(planeXY);

        const planeXZ = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({ color: axisColors.y, side: THREE.DoubleSide, transparent: true, opacity: 0.1 }));
        planeXZ.rotation.x = -Math.PI / 2;
        planeXZ.position.set(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2);
        planeGroup.add(planeXZ);
        
        const planeYZ = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({ color: axisColors.x, side: THREE.DoubleSide, transparent: true, opacity: 0.1 }));
        planeYZ.rotation.y = Math.PI / 2;
        planeYZ.position.set(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2);
        planeGroup.add(planeYZ);
        
        group.add(planeGroup);

        // 数据点
        const sphereGeometry = new THREE.SphereGeometry(0.12, 24, 24);
        mausoleumData.forEach(world => {
            const material = new THREE.MeshBasicMaterial({ color: world.color });
            const sphere = new THREE.Mesh(sphereGeometry, material);
            sphere.position.set(world.x * CUBE_SIZE, world.y * CUBE_SIZE, world.z * CUBE_SIZE);
            sphere.userData = world;
            group.add(sphere);
            objects.push(sphere);
        });
        
        // --- 5. 设置相机和控制器 ---
        camera.position.set(12, 12, 12);
        const center = new THREE.Vector3(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2);
        camera.lookAt(center);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.copy(center);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 6. 交互逻辑 ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        let intersectedObject = null;
        let lastMouseEvent = null; 

        window.addEventListener('mousemove', onMouseMove);
        
        function onMouseMove(event) {
            lastMouseEvent = event; 
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // UI Controls
        document.getElementById('toggle-title').addEventListener('change', (e) => {
            document.getElementById('header').style.opacity = e.target.checked ? '1' : '0';
        });
        document.getElementById('toggle-quadrants').addEventListener('change', (e) => {
            planeGroup.visible = e.target.checked;
        });

        // --- 7. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                if (intersectedObject !== intersects[0].object) {
                    intersectedObject = intersects[0].object;
                }
                tooltip.style.display = 'block';
                const data = intersectedObject.userData;
                const livabilityColor = data.color.getStyle();
                
                tooltip.innerHTML = `
                    <div class="flex flex-col space-y-3">
                        <div>
                            <p class="font-bold text-lg text-gray-900">${data.name_cn}</p>
                            <p class="text-sm text-gray-500 -mt-1">${data.name_en}</p>
                        </div>
                        <p class="text-sm text-gray-600 border-t border-gray-200 pt-2">${data.desc}</p>
                        <div class="grid grid-cols-3 gap-2 text-center border-t border-gray-200 pt-2">
                            <div>
                                <div class="text-xs text-gray-400">现实强度</div>
                                <div class="coord-label text-lg" style="color: ${axisColors.x};">${data.x.toFixed(4)}</div>
                            </div>
                            <div>
                                <div class="text-xs text-gray-400">个体自由度</div>
                                <div class="coord-label text-lg" style="color: ${axisColors.y};">${data.y.toFixed(4)}</div>
                            </div>
                            <div>
                                <div class="text-xs text-gray-400">无序度</div>
                                <div class="coord-label text-lg" style="color: ${axisColors.z};">${data.z.toFixed(4)}</div>
                            </div>
                        </div>
                        <div class="border-t border-gray-200 pt-2 flex justify-between items-center">
                            <span class="font-bold text-gray-700">宜居度</span>
                            <span class="livability-text text-xl" style="color: ${livabilityColor}; text-shadow: 0 0 8px ${livabilityColor}99;">${data.livability.toFixed(4)}</span>
                        </div>
                    </div>
                `;
            } else {
                intersectedObject = null;
                tooltip.style.display = 'none';
            }

            if (lastMouseEvent && tooltip.style.display === 'block') {
                let x = lastMouseEvent.clientX + 20;
                let y = lastMouseEvent.clientY + 20;
                
                if (x + tooltip.offsetWidth > window.innerWidth - 20) {
                    x = lastMouseEvent.clientX - tooltip.offsetWidth - 20;
                }
                if (y + tooltip.offsetHeight > window.innerHeight - 20) {
                    y = lastMouseEvent.clientY - tooltip.offsetHeight - 20;
                }
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        // --- 8. 窗口大小调整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
